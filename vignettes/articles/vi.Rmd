---
title: "vi"
output:
  rmarkdown::html_document:
    toc: true
    toc_title: "Contents"
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  eval = TRUE,
  collapse = TRUE,
  comment = "#>",
  out.width = "100%"
)
```

## Overview

The `vi` dataset contains ~10k records of Normalized Difference Vegetation Index (NDVI) with different encodings (see `vi_responses`) and a large set of numeric and categorical predictors (see `vi_predictors`) with consistent naming patterns (e.g., `temperature_*`, `rainfall_*`, `swi_*`).

Its main features are:

- *Complete case study* - No missing values, clean data ready for analysis.
- *Global scope* - 6 continents, all major climate zones, 12 biomes.
- *Grouped/stratified analysis* - Multiple hierarchical groupings available.

This dataset has several versions of the same response (see [vi_responses]) to support a wide range of analytical approaches: linear, count and ordinal regression, binary and multiclass classification, and mixed-effects models. 

It's large number of predictors allows testing dimensionality reduction and multicollinearity filtering methods, while it's dense point cloud helps test thinning, interpolation, spatial cross-validation, and spatial autocorrelation analyses.

## Setup

The following R libraries are required to run this tutorial:

```{r, include = FALSE}
if (!requireNamespace("pak", quietly = TRUE)) {
  install.packages("pak")
}
pak::pkg_install(
  c(
    "sf",
    "mapview",
    "dplyr",
    "spatialRF",
    "collinear",
    "viridis"
  ),
  ask = FALSE
)
```

```{r, message = FALSE, warning = FALSE, echo = FALSE}
library(spatialData)
library(sf)
library(mapview)
library(dplyr)
library(spatialRF)
library(collinear)
library(viridis)
```

The code below loads the example data.

```{r setup}
data(
  vi,
  vi_responses,
  vi_predictors,
  package = "spatialData"
  )
```

If you wish to work with a larger version (~30k) records of `vi`, you can download it with [vi_extra()].

```{r, eval = FALSE}
vi <- spatialData::vi_extra()
```


## Data Structure

The dataset is an `sf` data frame with `r nrow(vi)` rows and `r ncol(vi)` columns, and no missing data. The first 10 records and all columns but `geometry` are shown below.

```{r}
vi |>
  sf::st_drop_geometry() |>
  head(n = 10) |>
  dplyr::glimpse()
```

The spatial distribution of the data is irregular, and excludes regions with little to no vegetation activity (`vi$vi_numeric > 0`).


```{r}
mapview::mapview(
  vi,
  zcol = "vi_numeric",
  layer.name = "vi"
)
```


## Response Variables

The dataset provides **5 different encodings** (see `vi_responses`) of the same underlying vegetation index, enabling different modeling approaches:

| Variable | Type | Description | Use Case |
|----------|------|-------------|----------|
| `vi_numeric` | Continuous (0-1) | Raw NDVI values | Linear regression, GAM |
| `vi_counts` | Integer | `vi_numeric * 1000` as integer | Poisson/negative binomial regression |
| `vi_binomial` | Binary (0/1) | Thresholded to 0 or 1 | Logistic regression, classification |
| `vi_categorical` | Character | 5 categories based on quantiles | Multinomial models |
| `vi_factor` | Factor | `vi_categorical` as ordered factor | Ordinal regression |

## Predictor Variables

The dataset includes **58 predictor variables from 11 datasources**, of which 47 are numeric and 11 are categorical.

```{r}
vi |> 
  sf::st_drop_geometry() |> 
  dplyr::select(
    dplyr::all_of(vi_predictors)
  ) |> 
  head(n = 5) |> 
  dplyr::glimpse()
```

## Example Usage

This brief example shows how `vi` can be used to train a random forest model.

### Selection of Numeric Predictors

The `vi_predictors` vector contains both numeric and categorical variables. In this example we focus on the numeric ones, which can be extracted using `collinear::identify_numeric_variables()`.


```{r}
vi_predictors_numeric <- collinear::identify_numeric_variables(
    df = sf::st_drop_geometry(vi),
    predictors = vi_predictors
  )$valid

vi_predictors_numeric
```

### Multicollinearity Filtering

Many predictors in this dataset are highly correlated (e.g., `temperature_mean`, `temperature_max`, `temperature_min`). The `collinear::collinear()` function from the R package [`collinear`](https://blasbenito.github.io/collinear/) selects a non-redundant subset that maximizes predictive power for the response variable.

```{r}
predictors_selection <- collinear::collinear(
  df = vi,
  responses = "vi_numeric",
  predictors = vi_predictors_numeric,
  f = collinear::f_numeric_rf,
  quiet = TRUE
)

predictors_selection$vi_numeric$selection
```

### Random Forest Model

The response `vi_numeric` and the selected predictors are used below to train a random forest model using the R package [`spatialRF`](https://blasbenito.github.io/spatialRF/).

```{r}
m <- spatialRF::rf(
  data = sf::st_drop_geometry(vi),
  dependent.variable.name = "vi_numeric",
  predictor.variable.names = predictors_selection$vi_numeric$selection,
  verbose = FALSE
)

spatialRF::print_performance(model = m)
```

### Global Variable Importance

The permutation importance plot below indicates the variables that increase model errors the most when permuted.


```{r, fig.width=6, fig.height=4}
spatialRF::plot_importance(
  m = m,
  fill.color = viridis::viridis(n = 100)
)
```

### Local Variable Importance

The code below assigns to each observation the name of the predictor that matters most for that specific location's prediction, revealing geographic patterns in variable relevance.

```{r}
local_importance <- m$importance$local
vi$most_important <- colnames(local_importance)[max.col(local_importance)]

mapview::mapview(
  vi,
  zcol = "most_important",
  layer.name = "Most important predictor",
  col.regions = viridis::turbo(n = length(unique(vi$most_important)))
)
```

### Response Curves and Surfaces

The response curves below show how the response `vi_numeric` changes across the values of the most important predictors when all other predictors are set to their quantile 0.5.


```{r, fig.width=8, fig.height=6}
spatialRF::plot_response_curves(
  model = m,
  quantiles = 0.5
)
```

Finally, the response surface below shows how `rainfall_mean` and `soil_temperature_max` interact with each other to predict `vi_numeric`. The grey dots represent the actual observations of `vi_numeric`.


```{r, fig.width=5, fig.height=3.5}
spatialRF::plot_response_surface(
  m = m,
  a = "rainfall_mean",
  b = "soil_temperature_max",
  fill.color = viridis::viridis(n = 100),
  point.alpha = 0.05,
  point.size.range = c(0.05, 1)
)
```

The usage example above is only one of the many modeling approaches that can be applied to `vi`. Have fun with it!
